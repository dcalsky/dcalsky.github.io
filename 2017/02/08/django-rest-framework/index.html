<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="周左左个人博客"><title>Django rest framework 部分最佳实践 | 白玉为堂金为马</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.1"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Django rest framework 部分最佳实践</h1><a id="logo" href="/.">白玉为堂金为马</a><p class="description">70%有趣的灵魂</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Django rest framework 部分最佳实践</h1><div class="post-meta">Feb 8, 2017<span> | </span><span class="category"><a href="/categories/技术/">技术</a></span></div><div class="post-content"><p>DRF是我超喜欢的一款基于Django而创建的Restful API框架，项目开发效率大有提升。我来谈谈在使用DRF的过程中，有哪些最佳实践。</p>
<a id="more"></a>
<h2 id="序列化-Serialize"><a href="#序列化-Serialize" class="headerlink" title="序列化 Serialize"></a>序列化 Serialize</h2><p><code>serialize</code>这个名词也是在接触后Django rest framework后认识的，因为在很多web框架里都比较少用到，所以对其概念比较模糊。那么它到底是什么，又能为我们做些什么呢？</p>
<p>在前端jQuery库中，有一个.serialize()的方法，它不接受任何参数。用例如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$( <span class="string">"form"</span> ).on( <span class="string">"submit"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">  <span class="built_in">console</span>.log( $( <span class="keyword">this</span> ).serialize() );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<!-- more -->
<p>效果: <img src="http://static.noddl.me/1348908027b5cdcf19fafc014e5a938986f1921a-5a1d2aaec94ac5107d6dacaa272a2231a74db2a0.png" alt="demo"></p>
<p>从图中可以看出，此方法是将form表单抽象的数据规范化，以某格式化文本的方式表达出来了（图中为query string方式）。</p>
<p><code>回到django</code>，serializer的主要作用就是将model.py中建立的一个个抽象class的python原生实例转换为<code>json</code>或者<code>xml</code>的表达方式。太绕口了是吗？简而言之，从request获取client传来的数据，这些数据肯定是dict, tuple等众多数据类型，类型不统一。你可以将这些数据传入serializer中，它来负责帮你验证数据合法性、转换为<code>json or xml</code>格式的数据，甚至是直接帮你完成后续。</p>
<p>当初在学习的时候，我依然不了解我为什么需要serializer，我觉得django原生的开发效率反而更高，不需要去创建那些乱七八糟的serializers.py，甚至是将model里面的数据再在serializer里面重新写一遍。</p>
<p>但在深入了解rest framework工程化思想后，之前自己的想法显然naive了！<code>首先</code>：serializer提供了更多的数据验证方式，比如model里面没有的<code>min_length</code>、<code>UniqueValidator</code>, <code>write_only</code>。</p>
<p>当你真正开始写项目的时候，你就会知道，这些django原生里面都是没有自带的。需要在Model里手动创建类方法来判断request数据的合法性，以及痛苦地写着错误处理，再以json response返回给客户端。</p>
<p>如果你是一名后端开发的新手，一开始你写着一个个错误处理会觉得十分有成就感，感觉自己的程序又完善了几分。但是到后来你就会被庞大的json response或是try except等等淹没，并且面对着许多错误提示文本重复的问题（当然你也可以建立错误处理模块来减轻这种伤害）。</p>
<p>然后你再回头就可以看见serializer是多么的方便。如果这样仍然不足以打动你，对嘛，一个验证数据的功能而已。那么<code>视图</code>也许能够打动你，如果你已经拥有一个简单的serializer，在view中引入后，就能直接进行api操作，无需再自行处理诸如get、post、put等请求方法，你也知道为了处理这些，if语句可是需要写很多的。当然，这个功能需要配合<code>viewset</code>或是<code>class view</code>来实现。</p>
<p>讲了这么多，那么serializer到底长什么样呢？<img src="http://static.noddl.me/1d8a20874c8bc7518b20b88b34c41faf74108580-cfb87deac085d2e62f9328be10f0dee7ba97bf6a.png" alt="serializer"></p>
<p>我们自己建立的serializer类可以继承自两个rest framwork自带的类，具体有什么区别自行查阅文档。</p>
<p>username、password是我们注册时必要填写的两个field，所以我们当作类属性写在开头。</p>
<p>class Meta里面有两个属性，model当然是这个serializer属于哪个Model了，fields是设置我们需要这个Model里的哪些属性需要序列化的。你如果懒得一个个写，直接写<code>&#39;__all__&#39;</code>就行啦。</p>
<p>之后的直接的类方法，比如<code>validate</code>、<code>create</code>就是一个serializer在生命周期需要做的动作，你当然可以override它们，写上自己需要的功能。api文档里面写的都非常详细，我极力推荐你去看看。</p>
<h2 id="视图-Api-view"><a href="#视图-Api-view" class="headerlink" title="视图 Api view"></a>视图 Api view</h2><h3 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h3><p>根据model建立好serializer，接下来我们就可以开始构建视图了。views.py</p>
<p>其实关于views的最佳实践，我目前只是探索到<code>generics</code>与<code>mixins</code>，而最为玄学的<code>viewset</code>没来得及去探索。但是对于一般的功能，这两个足够了。</p>
<p>现在我提出两个需求：</p>
<ol>
<li>对User的CRUD；</li>
<li>判断username是否已经被占用。</li>
</ol>
<p>既然存在CRUD，我们就需要使用<code>rest_framework.generics</code>了。首先引入这个模块，之后对我们的需求进行判断。我们需要：1、能够查看所有的user，2、查看单个user的具体资料，3、创建一个用户（注册），4、修改、删除一个特定的用户。</p>
<p>我们将1、3列为一组，2、4为一组。为什么呢？因为第一组都是针对用户组（未特指某用户）而言的，而第二组是针对某一特定用户的。</p>
<p>于是我们构建这两个类:</p>
<p><img src="http://static.noddl.me/5ea8460d1256b7bef4d9d980276e3b2ef6366bd9-c01134f5a2f720b067e826f7aa740b6010fe3418.png" alt="view"></p>
<p>serializer_class为我们视图是对应哪个序列化而进行操作的，queryset需要得到Model的所有成员。然后呢？<code>没了，第一个需求基本就做完了</code>。</p>
<p><code>ListCreateAPIView</code>封装了三种mode：列出所有User、创建一个User、生成API视图。</p>
<p>那同理：<code>RetrieveUpdateAPIView</code>就封装了查看特定User，修改特定User等动作。</p>
<p>我们在urls.py里引入。<img src="http://static.noddl.me/0115ffd40d029c738a54a632168b19fb254dc072-1ee0c443e0736273b59ffcc2d04d951db824ab37.png" alt="urls"></p>
<p>于是我们的第一个需求就做完了。我们访问<code>localhost:8000/users</code>就可以看见django-rest-framework为我们创建基本界面。</p>
<p><img src="http://static.noddl.me/59c31e677ffc28f8cebb23fbaeafd56eb38ea4fa-1971bb2578dc917618fd7e4c92594f27d262fb45.png" alt="view"></p>
<h3 id="单独功能"><a href="#单独功能" class="headerlink" title="单独功能"></a>单独功能</h3><p>我们还剩下一个<code>检查用户名是否已经被注册</code>的需求没有实现，简单分析一下：这里并没有对User资源进行CUD操作，只有read(GET)操作，而且也并非正规地查阅User实例的信息。所以不能使用rest framework帮我们封装的CRUD视图。</p>
<p>那么我们可以将URL设计成example.com/users/<username>/check，然后传入需要进行查询的username就行了。那么在view里又该如何去做呢？<img src="http://static.noddl.me/7e511e20906c3388ed0f64fd8a95d9ccb0c5e3ad-e43835a907b81c7a8606c1b5a2c4fe80cd4d163c.png" alt="check">利用一些装饰器来实现控制Request method与Permission管理。这里我们只支持get请求，并且规定所有人（无论登录与否）都可以调用这一接口。引入它们:<code>from rest_framework.decorators import api_view, permission_classes</code></username></p>
<p>然后我们根据url传入的username，使用Django自带的User Model来进行用户名是否存在的检查，<code>Response</code>也是rest framework为我们提供的序列化的返回响应方法，还可以附带data与status。</p>
<p><code>from rest_framework.response import Response</code>这样就可以引入它了。</p>
</div><div class="tags"><a href="/tags/django/">django</a><a href="/tags/django-rest-framework/">django-rest-framework</a><a href="/tags/serializer/">serializer</a></div><div class="post-nav"><a class="pre" href="/2017/02/21/fish_hook/">webhook革命 使用fish-hook自动部署多个应用</a><a class="next" href="/2016/06/06/summer_note/">夏天到的时候，我有一堆话要讲</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/摄影/">摄影</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂谈/">杂谈</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.zhihu.com/people/dcalsky" title="知乎" target="_blank">知乎</a><ul></ul><a href="https://github.com/dcalsky" title="Github" target="_blank">Github</a><ul></ul><a href="mailto:dcalsky@gmail.com" title="电子邮箱" target="_blank">电子邮箱</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">白玉为堂金为马.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.1" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.1"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.1"></script></div></body></html>