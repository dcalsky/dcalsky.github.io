<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="周左左个人博客"><meta name="theme-color" content="#C6FF00"><title>Cocos2d-x之监听键盘按住事件 | 白玉为堂金为马</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.1"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Cocos2d-x之监听键盘按住事件</h1><a id="logo" href="/.">白玉为堂金为马</a><p class="description">70%有趣的灵魂</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Cocos2d-x之监听键盘按住事件</h1><div class="post-meta">May 7, 2016<span> | </span><span class="category"><a href="/categories/技术/">技术</a></span></div><div class="post-content"><p>我只想让精灵一直向前走，为什么这么难？<br><a id="more"></a></p>
<p><img src="http://
static.noddl.me/zombie1.png?imageslim" alt="zombie"></p>
<h2 id="一切故事发生的背景"><a href="#一切故事发生的背景" class="headerlink" title="一切故事发生的背景"></a>一切故事发生的背景</h2><p>同济大学软件学院每个学期会要求学生独立或者组队完成一个大项目，于是2016年大项目是用<em>cocos2d-x</em>这款引擎制作一个自己的游戏。</p>
<p>有幸能和大神组到了一起，形成了两人小分队。</p>
<p>C++语言方面我还真的没有拿得出的东西，但是在<em>cocos2d-x</em>的学习中，还是略有收获的。今天想谈谈通过监听键盘事件从而让精灵一直走路，松开按键精灵就停下的功能。就好像骑车一样，按住一颗按键，就会向前行驶，不按就停下来。</p>
<h2 id="一个简单的Sprite"><a href="#一个简单的Sprite" class="headerlink" title="一个简单的Sprite"></a>一个简单的Sprite</h2><p>先在Demo.h里声明出一个sprite成员作为我们今天的主角,顾名思义我叫它hero，因为是简单的例子，就不兴师动众创建一个严谨的主角类了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Demo.h</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> :</span> <span class="keyword">public</span> cocos2d::Layer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> cocos2d::<span class="function">Scene* <span class="title">createScene</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">    cocos2d::Sprite *hero;</span><br><span class="line">    <span class="comment">// a selector callback</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">menuCloseCallback</span><span class="params">(cocos2d::Ref* pSender)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> delta)</span> override</span>;</span><br><span class="line">    <span class="comment">// implement the "static create()" method manually</span></span><br><span class="line">    CREATE_FUNC(HelloWorld);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<!-- more -->
<h3 id="添加一个”僵尸”sprite"><a href="#添加一个”僵尸”sprite" class="headerlink" title="添加一个”僵尸”sprite"></a>添加一个”僵尸”sprite</h3><p>再在Demo.cpp中实实在在创建出这个带有纹理的sprite，设置居中位置，并添加到场景中。<br>就像开头贴出的效果图，我们能够控制的精灵纹理是一张《植物大战僵尸》中僵尸的贴图，而背景其实也是一个精灵对象，相关代码就不在此列出了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Demo.cpp</span><br><span class="line"></span><br><span class="line">hero = Sprite::create(<span class="string">"zombie.png"</span>);</span><br><span class="line"><span class="comment">// position the sprite on the center of the screen</span></span><br><span class="line">hero-&gt;setPosition(Vec2(visibleSize.width/<span class="number">2</span> + origin.x, visibleSize.height/<span class="number">2</span> + origin.y));</span><br><span class="line"><span class="comment">// add the sprite as a child to this layer</span></span><br><span class="line"><span class="keyword">this</span>-&gt;addChild(hero, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h3 id="添加键盘事件监听"><a href="#添加键盘事件监听" class="headerlink" title="添加键盘事件监听"></a>添加键盘事件监听</h3><p>我相信你一定会一些基本的事件监听(Event Dispatcher)使用方法了吧，如果不是，请参照<a href="http://www.cocos2d-x.org/docs/programmers-guide/8/index.html" target="_blank" rel="noopener">官方文档中的该章节</a>。</p>
<p>当然其中有一些鼠标监听之类的方法不是我们今天需要的，<em>EventListenerKeyboard</em>才是今天的重头戏。于是我们在Demo.cpp 中创建一个监听器，并赋予一个lambda函数给它，让它能知道监听了键盘事件后该做什么事情。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Demo.cpp</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> listener = EventListenerKeyboard::create();</span><br><span class="line">listener-&gt;onKeyPressed = [=](EventKeyboard::KeyCode keyCode, Event* event)&#123;</span><br><span class="line">	<span class="built_in">log</span>(<span class="string">"key pressed"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_eventDispatcher-&gt;addEventListenerWithSceneGraphPriority(listener, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>这样一来，按任意键，控制台就会输出”key pressed”字样的信息了，这为我们下一步做了良好的铺垫。传进来的参数是什么意思？不必解释了吧… </p>
<h3 id="记录一共按过哪些键，以及其状态"><a href="#记录一共按过哪些键，以及其状态" class="headerlink" title="记录一共按过哪些键，以及其状态"></a>记录一共按过哪些键，以及其状态</h3><p>我们还要记录一下一共按过了哪些键，以及现在它们是否还被按着。通俗地讲，就是用KeyPressed事件将当期按下的键信息保存起来，表示它现在被按下了。再判断触发KeyReleased事件时，将触发的按键信息去除掉，表示现在这颗键已经不再处于被按下的状态了。</p>
<p>于是我们在头文件里创建一个map类型的成员，取名为keys,用以保存我们按键记录。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Demo.h</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> :</span> <span class="keyword">public</span> cocos2d::Layer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> cocos2d::<span class="function">Scene* <span class="title">createScene</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">    cocos2d::Sprite *hero;</span><br><span class="line">    <span class="comment">// a selector callback</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">menuCloseCallback</span><span class="params">(cocos2d::Ref* pSender)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> delta)</span> override</span>;</span><br><span class="line">    <span class="comment">// implement the "static create()" method manually</span></span><br><span class="line">    CREATE_FUNC(HelloWorld);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;cocos2d::EventKeyboard::KeyCode, <span class="keyword">bool</span>&gt; keys;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>map键为每个按键所对应的keycode, 值为现在这颗按键是不是处于被按下的状态，正在被按为true, 没被按(即 松开)为false。</p>
<p>当然，我们还要为键盘监听器添加一个KeyReleased事件，用以监听任意按键被松开那一刻的状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Demo.cpp</span><br><span class="line"></span><br><span class="line">listener-&gt;onKeyReleased = [=](EventKeyboard::KeyCode keyCode, Event* event)&#123;</span><br><span class="line">   <span class="built_in">log</span>(<span class="string">"key release"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>简简单单一些在控制台的输出是远远不够的，现在开始改进我们的俩监听事件，让它们能增加或改变keys里的记录。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Demo.cpp</span><br><span class="line"></span><br><span class="line">listener-&gt;onKeyPressed = [=](EventKeyboard::KeyCode keyCode, Event* event)&#123;</span><br><span class="line">	keys[KeyCode] = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">listener-&gt;onKeyReleased = [=](EventKeyboard::KeyCode keyCode, Event* event)&#123;</span><br><span class="line">   keys[KeyCode] = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>你问我为何可以写得如此草率简单，然而事实就是如此。在松开事件发生的时候，根本不需要判断在keys是不是已经存在了这个按键，因为，被松开就代表着，肯定被按下了。当然，我们排除在游戏之外的窗口按下，再切换到游戏内松开的情况，对于这种非法份子，今天网开一面。</p>
<h2 id="Sprite-show-me-your-hands"><a href="#Sprite-show-me-your-hands" class="headerlink" title="Sprite show me your hands"></a>Sprite show me your hands</h2><h3 id="老朋友update事件"><a href="#老朋友update事件" class="headerlink" title="老朋友update事件"></a>老朋友update事件</h3><p>每一个由Node类继承下来的子类中，无论你是精灵类，场景类，都有一个update方法，当判断发生改变时，能够做出一些反应。</p>
<p>要使用update，先要了解三种调度器<a href="http://www.cocos.com/doc/article/index?type=cocos2d-x&amp;url=/doc/cocos-docs-master/manual/framework/native/v3/scheduler/zh.md" target="_blank" rel="noopener">Scheduler</a></p>
<p>我们为Demo类添加一个默认调度器，表示它要使用update方法。并且添加一些简单的代码到update事件中去。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Demo.cpp</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> HelloWorld::init() &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">this</span>-&gt;scheduleUpdate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> HelloWorld::update(<span class="keyword">float</span> delta) &#123;</span><br><span class="line">    <span class="comment">// Register an update function that checks to see if the CTRL key is pressed</span></span><br><span class="line">    <span class="comment">// and if it is displays how long, otherwise tell the user to press it</span></span><br><span class="line">    Node::update(delta);</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">"update"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开游戏以后，就会看见控制台正在疯狂地输出”update”，说明我们的默认调度器监听了每一帧的改变并执行了我们自定义的操作。</p>
<h3 id="你真的…一直在按着我吗？"><a href="#你真的…一直在按着我吗？" class="headerlink" title="你真的…一直在按着我吗？"></a>你真的…一直在按着我吗？</h3><p>我们创建一个方法，叫做isKeyPressed，用来判断一个按键是否当前是否处于被按下的状态，如果是，返回true，交给update来处理后续动作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Demo.cpp</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> HelloWorld::isKeyPressed(EventKeyboard::KeyCode keyCode) &#123;</span><br><span class="line">    <span class="keyword">if</span>(keys[keyCode]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时时刻刻判断特定的按键是否被按下"><a href="#时时刻刻判断特定的按键是否被按下" class="headerlink" title="时时刻刻判断特定的按键是否被按下"></a>时时刻刻判断特定的按键是否被按下</h3><p>除了上下左右键，其他的我们都不需要理会，这个需求如何实现呢？</p>
<p>我们要让之前创建好的hero左右动，那就要在update事件中时时刻刻判断着KEY_LEFT_ARROW或者KEY_RIGHT_ARROW是否被按下，如果是，就对主角执行动作(action)，没有，就忽略。</p>
<p>我们将update方法进行改写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Demo.cpp</span><br><span class="line"><span class="keyword">void</span> HelloWorld::update(<span class="keyword">float</span> delta) &#123;</span><br><span class="line">    Node::update(delta);</span><br><span class="line">    <span class="keyword">auto</span> leftArrow = EventKeyboard::KeyCode::KEY_LEFT_ARROW, rightArrow = EventKeyboard::KeyCode::KEY_RIGHT_ARROW;</span><br><span class="line">    <span class="keyword">if</span>(isKeyPressed(leftArrow)) &#123;</span><br><span class="line">        keyPressedDuration(leftArrow);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isKeyPressed(rightArrow)) &#123;</span><br><span class="line">        keyPressedDuration(rightArrow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等等，keyPressedDuration是什么东西，内置方法吗？我们接着看。</p>
<h2 id="Hero-我该做些什么呢？"><a href="#Hero-我该做些什么呢？" class="headerlink" title="Hero: 我该做些什么呢？"></a>Hero: 我该做些什么呢？</h2><p>差不多都快要搞定的时候，我们的hero发现了一个严重的问题 — 它该做些什么。</p>
<p>我们新创建一个方法叫做keyPressedDuration，表示着按下/按着对应按键后，hero应该做些什么。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Demo.cpp</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> HelloWorld::keyPressedDuration(EventKeyboard::KeyCode code) &#123;</span><br><span class="line">    <span class="keyword">int</span> offsetX = <span class="number">0</span>, offsetY = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        <span class="keyword">case</span> EventKeyboard::KeyCode::KEY_LEFT_ARROW:</span><br><span class="line">            offsetX = <span class="number">-5</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EventKeyboard::KeyCode::KEY_RIGHT_ARROW:</span><br><span class="line">            offsetX = <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            offsetY = offsetX = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0.3s代表着动作从开始到结束所用的时间，从而显得不会那么机械。</span></span><br><span class="line">    <span class="keyword">auto</span> moveTo = MoveTo::create(<span class="number">0.3</span>, Vec2(hero-&gt;getPositionX() + offsetX, hero-&gt;getPositionY() + offsetY));</span><br><span class="line">    hero-&gt;runAction(moveTo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们判断code变量从而得知用户按了左右键中的哪一个，再执行对应的动作。</p>
<h2 id="烂尾"><a href="#烂尾" class="headerlink" title="烂尾"></a>烂尾</h2><p>最后的最后，我们将代码一整合，按住左键或者右键，就可以看见hero自由地走动啦。</p>
<p>本来作为一名cocos2d-x的初学者，遇到这种问题，我通常就面向csdn和stackoverflow编程了，通过他们来解决我的问题。可无奈，我竟然难以找到令我真正看得懂的教程，英文尚有几篇，而中文关于这方面的根本没有。</p>
<p>既然没有，虽然我才刚刚学习，但本着不逃避的态度，那就我来写一篇吧。</p>
<p>下一章就该讲讲我和物理引擎的一些故事了，下期再见。</p>
<p>以上。</p>
</div><div class="tags"><a href="/tags/cocos2d-x/">cocos2d-x</a><a href="/tags/游戏开发/">游戏开发</a></div><div class="post-nav"><a class="pre" href="/2016/05/19/cocos2dx_physics_engine/">Cocos2d-x之物理引擎</a><a class="next" href="/2016/05/04/stylus_on_django/">Django项目中的stylus</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/摄影/">摄影</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂谈/">杂谈</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.zhihu.com/people/dcalsky" title="知乎" target="_blank">知乎</a><ul></ul><a href="https://github.com/dcalsky" title="Github" target="_blank">Github</a><ul></ul><a href="mailto:dcalsky@gmail.com" title="电子邮箱" target="_blank">电子邮箱</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">白玉为堂金为马.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.1" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.1"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.1"></script></div></body></html>