<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="周左左个人博客"><meta name="theme-color" content="#AEEA00"><title>Cocos2d-x之物理引擎 | 白玉为堂金为马</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.1"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Cocos2d-x之物理引擎</h1><a id="logo" href="/.">白玉为堂金为马</a><p class="description">70%有趣的灵魂</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Cocos2d-x之物理引擎</h1><div class="post-meta">May 19, 2016<span> | </span><span class="category"><a href="/categories/技术/">技术</a></span></div><div class="post-content"><p>我连什么是重力都不懂，却让我开始用物理引擎。<br><a id="more"></a></p>
<p><img src="http://static.noddl.me/zombie2.png?imageslim" alt="zombie"></p>
<h2 id="一切故事发生的背景"><a href="#一切故事发生的背景" class="headerlink" title="一切故事发生的背景"></a>一切故事发生的背景</h2><p>之前写了一篇<em>cocos2d-x</em>关于键盘按住事件的教程，不足之处还请大家多多指出。</p>
<p>在自己做练习的过程中，逐渐接触到了碰撞，行走，降落一类的行为。我发现，如果全部由自己来实现，不仅实现起来复杂，而且执行效率也不一定见得高，所以我决心开始学习cocos2d-x Physics 2D。</p>
<h2 id="物理引擎的基础"><a href="#物理引擎的基础" class="headerlink" title="物理引擎的基础"></a>物理引擎的基础</h2><h3 id="两种物理引擎"><a href="#两种物理引擎" class="headerlink" title="两种物理引擎"></a>两种物理引擎</h3><p>根据<a href="http://www.cocos.com/doc/article/index?type=wiki&amp;url=/doc/cocos-docs-master/manual/framework/native/wiki/physics/zh.md" target="_blank" rel="noopener">官方文档</a>的介绍，目前有两大重要的物理引擎， Box2D 和 Chipmunk，并且cocos2d-x已经集成了它们，在3.x版本中可基于Chipmunk的核心API的物理引擎使用。</p>
<p>一句话： <em>cocos2d-x 3.x版本中使用Chipmunk物理引擎更加方便了</em>，大家都升级成3.x吧=。=</p>
<h3 id="为什么要用物理引擎"><a href="#为什么要用物理引擎" class="headerlink" title="为什么要用物理引擎"></a>为什么要用物理引擎</h3><p>我为什么要用物理引擎？举个开发中遇到的问题，在上一期的博文中，我们成功创建了一个hero sprite（对，就是那个可爱的僵尸）。现在我们要再创建一个坚果墙 sprite，叫做 wall sprite，它的作用是：hero会被wall而无法继续前进。</p>
<p>大家都知道，如果什么都不设置，我们控制hero的时候，是会直接穿过wall sprite的。<em>这肯定不是我们想要的</em>，机智的霄同学就想到了一个办法：获取hero要走的下一步位置（仔细看看上一期，就会发现这并不难），然后再判断这个位置（Point）是不是存在一个精灵，如果是，就强制取消移动命令。</p>
<p>好办法啊，思路清晰，我简直要为他鼓掌了。</p>
<p>方法虽好，可惜我不会。之前提到过，我是一个呆呆呆呆的初学者，我只想用最方便的方式来实现我要的效我甚至不惜牺牲程序的效率来追求减少代码量，一想到要再次封装一大堆，我就烫烫烫。</p>
<p>cocos2d-x physics 2D就可以完美解决这个问题，而且方法十分简单。</p>
<!-- more -->
<h3 id="存在物理规律的世界？"><a href="#存在物理规律的世界？" class="headerlink" title="存在物理规律的世界？"></a>存在物理规律的世界？</h3><p>我们这个世界受着来自物理规律的支配，那么物理引擎创建出来的scene也同样要存在某种物理规律，身为造物主的你可以自由定义这些规律。</p>
<p>首先，我们在Demo.cpp中创建一个物理世界。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Scene* Demo::createScene()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> scene = Scene::createWithPhysics();</span><br><span class="line">    <span class="keyword">auto</span> layer = HelloWorld::create();</span><br><span class="line">    scene-&gt;addChild(layer);</span><br><span class="line">    <span class="keyword">return</span> scene;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单对吧？只需要将Scene::create改成Scene::createWithPhysics，在这里scene中的物理世界就算创建成功啦。</p>
<h3 id="重新创建sprites"><a href="#重新创建sprites" class="headerlink" title="重新创建sprites"></a>重新创建sprites</h3><p>上一次教程中，我们创建了一个hero sprite， 创建的方法是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> hero = Sprite::create(<span class="string">"hero.png"</span>);</span><br></pre></td></tr></table></figure>
<p>太愚蠢了是不是？高贵的物理世界怎么能这样呢？…</p>
<p>很遗憾，这样的创建方式是没错的，我们<em>依然沿袭这个方法</em>来创建sprite。</p>
<p>如果此时，你开启调试，就会发现sprite没有开始自由落体运动。那到底是哪里出现了问题呢？</p>
<p>这样创建出来的sprite只是一个空壳而已，它没有任何灵魂和信仰的力量(Physics body)，我们此时需要给这只可怜的小家伙+1s信仰。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> heroBody = PhysicsBody::createBox(hero-&gt;getContentSize());</span><br><span class="line">hero-&gt;setPhysicsBody(bodyHero);</span><br></pre></td></tr></table></figure>
<p>这样，它拥有了一个Physics body。现在再调试，你就发现我们可爱的hero已经在自由落体了。</p>
<p>可是，你不想听听createBox到底是什么意思吗？body存在一个边界，里面的空间表示sprite的实体。而这个边界有几种存在的形态：矩形、圆形和多边形。</p>
<p>在刚刚的例子中，我们创建了一个矩形的边界，规定了边界范围是hero sprite的大小（png图片）。再说说之后要创建的坚果墙吧，它的形状基本趋近一个圆形，那么则可以使用createCircle的方法来创建它的body.</p>
<p>setPhysicsBody顾名思义，就是将我们的灵魂(body)赋给hero sprite.</p>
<h3 id="掉…掉下去了"><a href="#掉…掉下去了" class="headerlink" title="掉…掉下去了"></a>掉…掉下去了</h3><p>看着我们的hero能够实现自由落体，我也很开心啊。可是…不一会儿，它就掉到屏幕外面去了，怎么办？</p>
<p>恍然大悟，我们的<em>背景图片（它也是一个sprite，这不能忘啊）</em>,没有被添加body。但是我们又发现一个问题，body是进不去的，所以，物理引擎专门提供了一个方法createEdgeBox，只创建边界。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Demo.cpp</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">map</span> = Sprite::create(<span class="string">"background.png"</span>);</span><br><span class="line"><span class="keyword">auto</span> mapFrame = PhysicsBody::createEdgeBox(<span class="built_in">map</span>-&gt;getContentSize());</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>-&gt;setPhysicsBody(mapFrame);</span><br></pre></td></tr></table></figure>
<p>再次调试，hero稳稳地落在了地面上。</p>
<h2 id="支配我的世界"><a href="#支配我的世界" class="headerlink" title="支配我的世界"></a>支配我的世界</h2><p>虽然我不知道什么是G = mg，但是我知道世界上一定是有重力的，嗯。所以我们创建出来的scene中的物体也需要受到重力的作用。<br><img src="http://
static.noddl.me/be6201d0492e5fdeab5b7ea574581396b99c26fe-bbe18a87a87c3dcfdd93719418226ca81815ba16.png" alt="API"><br>看API文档了解到我们需要传入一个Vec2类型的重力参数，第一个和第二个数值是什么意思呢？我通过xcode进行调试发现:<br><img src="http://
static.noddl.me/7a2fc42ff21defe758dd505f4d1c21bb6a3f4b68-8ebf612cdd73799332691cb10972ced60a4bd88f.png" alt="debug"><br>第二个数值为默认的重力，98。那么我们就可以通过setGravity方法来设置属于我们自己的重力了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Demo.cpp</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> scene = Scene::createWithPhysics();</span><br><span class="line">scene-&gt;getPhysicsWorld()-&gt;setGravity(Vec2(<span class="number">0.0f</span>, <span class="number">-500.0f</span>));</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>先使用物理scene中的getPhysicsWorld方法来获取我们的物理世界，然后再设置重力，经过调试就可以看见hero sprite和wall sprite飞快地加速下降了。</p>
<p>还有很多好玩的功能强劲的API可以供大家使用，比如getAllBodies，都等着我们去探索。</p>
<h3 id="关系到具体body的属性"><a href="#关系到具体body的属性" class="headerlink" title="关系到具体body的属性"></a>关系到具体body的属性</h3><p>那么我想为hero sprite和wall sprite添加一些属于他们自己的物理属性，怎么做到呢？</p>
<p>就像现实世界中有人质量大，有人质量小一样，我要给坚果墙设置一个极大的质量以至于不可动摇，而僵尸（our hero）就可以自由行动（如何自由行动上一期已经说过啦~）。</p>
<p>就像API中所提到的，可以在创建Physics body的时候，就传入一个physics material进去。<br><img src="http://
static.noddl.me/37fe5edd1d06989f02435549268323b030f8462d-9a94e3cedc244961daa14766b294bb73ab95d620.png" alt="API"></p>
<p>之前我们只是传入一个sprite content进去（第一个参数），现在要传入更多的参数，使hero sprite的physics body达到我们预期的效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Demo.cpp</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> hero = Sprite::create(<span class="string">"hero.png"</span>);</span><br><span class="line"><span class="keyword">auto</span> heroBody = PhysicsBody::createBox(hero-&gt;getContentSize(), PhysicsMaterial(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">20.0f</span>));</span><br></pre></td></tr></table></figure>
<p>什么是Physics Material呢？<img src="http://
static.noddl.me/59b4c75f45ec33e3e6f900ca838ffd2d8075e345-c98c774fafbd2c8190b212f150a9fbd0198a6910.png" alt="physics material"></p>
<p>根据API可知，我们可以调用这个类的构造函数来创建一个physics material，使得physics body获取一定量的材质。密度，还原力和摩擦力。对于我们的需求来说，只要设置必要的摩擦力就够了。</p>
<p>第三个参数offset为偏移量，想要physics body和sprite的位置错开的话，可以填写这个参数。</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">heroBody-&gt;setDynamic(<span class="literal">true</span>);      <span class="comment">//设置为静态的刚体，不受重力影响  </span></span><br><span class="line">heroBody-&gt;setMass(<span class="number">999999</span>);  <span class="comment">//设置刚体不可动  </span></span><br><span class="line">heroBody-&gt;setRotationEnable(<span class="literal">false</span>);      <span class="comment">//设置刚体不可转动  </span></span><br><span class="line">heroBody-&gt;getShape(<span class="number">0</span>)-&gt;setRestitution(<span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure>
<p>这些都是可以在API文档中找到设置physics body的方法，学会之后就可以随心所欲地创建属于自己的物理场景了。</p>
<h2 id="没有重力的世界"><a href="#没有重力的世界" class="headerlink" title="没有重力的世界"></a>没有重力的世界</h2><blockquote>
<blockquote>
<p>不是所有游戏都是2D横版闯关的，比如上帝视角。<br>重力在这个场景中存在吗？存在，但是它不是明目张胆地表现出来。就比如一个个小棋子，定格在棋盘上，此时我们不能为这个场景添加重力，于是：</p>
</blockquote>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Demo1.cpp</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> scene = Scene::createWithPhysics();</span><br><span class="line">scene-&gt;getPhysicsWorld()-&gt;setGravity(Vec2(<span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>并且还要为sprite设置不受重力影响的效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Demo1.cpp</span><br><span class="line"><span class="keyword">auto</span> sprite = Sprite::create(<span class="string">"sprite.png"</span>);</span><br><span class="line"><span class="keyword">auto</span> spriteBody = PhysicsBody::createBox(sprite-&gt;getContentSize());</span><br><span class="line">spriteBody-&gt;setGravityEnable(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>这样，我们的小棋子就定格在棋盘上了。</p>
<h3 id="动动动动起来"><a href="#动动动动起来" class="headerlink" title="动动动动起来"></a>动动动动起来</h3><p>既然没有了重力，我们如何让它们在存在一个作用力的情况下，让它们停下来呢？</p>
<p>首先，你需要一个<em>作用力</em>。applyForce和applyImpulse这两个方法能够很好地帮助我们创建给物体施加的力。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Demo1.cpp</span><br><span class="line"></span><br><span class="line">spriteBody-&gt;applyForce(Vec2(<span class="number">100.0f</span>, <span class="number">100.0f</span>));</span><br><span class="line"><span class="comment">// spriteBody-&gt;applyImpulse(Vec2(100.0f, 100.0f));</span></span><br></pre></td></tr></table></figure>
<p>我们将物体发射到点100.0, 100.0的位置方向去。我还没来得及解释这两个方法是什么意思的时候，心急的朋友就马上开始调试了，结果发现sprite并没有按照预期的那样动起来。这是为什么呢？</p>
<p><em>因为力不够大啊孩子</em>，很神奇的是，我们似乎只规定了力的反向而力的大小并没有被规定，但是又如何衡量一个力的大小呢？这是一个很令人纠结的问题。</p>
<p><img src="http://
static.noddl.me/55674d533b6f9da009b8d777d02a04fd1af8e2f6-7426f3d74f00e4fccc24d8105ded28b805f50547.png" alt="force"></p>
<p>且先来看文档, 参数只要求填入一个Vec2类型的数值，而且注释是force … </p>
<p>会不会是默认了添加1N的力呢？于是我将代码改成下面这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Demo1.cpp</span><br><span class="line"></span><br><span class="line">spriteBody-&gt;applyForce(Vec2(<span class="number">100.0f</span>, <span class="number">100.0f</span>) * <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// spriteBody-&gt;applyImpulse(Vec2(100.0f, 100.0f) * 1000);</span></span><br></pre></td></tr></table></figure>
<p>果然，精灵动了起来。但是问题又来了，不一会，我就发现精灵根本没有停下来的意思，它在不停地运动。</p>
<p>造成这种问题，主要有两个原因：1、没有摩擦力；2、添加力的方式存在问题。</p>
<p>趁热打铁，我们先来解决力的问题。applyForce有什么问题吗？我们仔细看看API文档就会发现，这是添加了一个持续的力，<em>这个力会不停地添加在sprite上，直到你手动地将其停下来。</em></p>
<p>那么我们需要一个瞬间的力，就类似弹弓一样。applyImpulse这个时候就出场啦。这个方法能为物体添加一个瞬时的力。</p>
<p><img src="http://
static.noddl.me/ebe3e5f98bbe2296a1d1747bd060524139e6cb71-358e3fa443dcc222b996242955465121f5281769.png" alt="impulse"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Demo1.cpp</span><br><span class="line"></span><br><span class="line">spriteBody-&gt;applyImpulse(Vec2(<span class="number">100.0f</span>, <span class="number">100.0f</span>) * <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// spriteBody-&gt;applyForce(Vec2(100.0f, 100.0f) * 1000);</span></span><br></pre></td></tr></table></figure>
<h3 id="快快快快快停下"><a href="#快快快快快停下" class="headerlink" title="快快快快快停下"></a>快快快快快停下</h3><p>可是我们发现精灵还是不能很好地停下，但是至少它不会像之前那么飞奔了。</p>
<p>刚刚说了，摩擦力存在问题。我们不是已经设置过摩擦力了吗？它会有什么问题呢？</p>
<p>摩擦力不代表空气阻力，在cocos2d-x的物理引擎创建的世界中，是默认不存在空气阻力这个高大上的属性的。</p>
<p>完蛋，物理引擎都没提供的功能，让我如何是好啊。很幸运的是，physics body提供了一个叫做setLinearDamping(设置线性阻尼)的方法。</p>
<p><img src="http://
static.noddl.me/b29fac2487a371962f7cccf0d3686788635ced5b-436fdc20fe32b425f946fe8b2eeb131b16a74f7c.png" alt="linear damping"></p>
<p>这个方法可以很好地使在无重力状态下的物体停下来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Demo1.cpp</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">spriteBody-&gt;setLinearDamping(<span class="number">5.0f</span>);</span><br></pre></td></tr></table></figure>
<p>我将sprite body的阻尼设置为5.0f，其所产生的具体效果，肯定要在调试中才能看出。<br>很好，sprite在飞一段时间后，能很好地停下来了。</p>
<h2 id="烂尾"><a href="#烂尾" class="headerlink" title="烂尾"></a>烂尾</h2><p>当然物理引擎的魅力到这里还并没有被完全探索出来，只是给大家一个系统地学习方案而已。</p>
<p>还是那句老话，我希望将所学的一切用来解决实际的问题并将其转化为生产力，以上的全部都是我在学习中了解到的，每一章节都包含了很多小坑坑，不断地填补，以至刻骨铭心。</p>
<p>以上。</p>
</div><div class="tags"><a href="/tags/cocos2d-x/">cocos2d-x</a><a href="/tags/游戏开发/">游戏开发</a><a href="/tags/物理引擎/">物理引擎</a></div><div class="post-nav"><a class="pre" href="/2016/06/06/summer_note/">夏天到的时候，我有一堆话要讲</a><a class="next" href="/2016/05/07/cocos2dx_keep_going/">Cocos2d-x之监听键盘按住事件</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/杂谈/">杂谈</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/摄影/">摄影</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂谈/">杂谈</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/诗/">诗</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.zhihu.com/people/dcalsky" title="知乎" target="_blank">知乎</a><ul></ul><a href="https://github.com/dcalsky" title="Github" target="_blank">Github</a><ul></ul><a href="mailto:dcalsky@gmail.com" title="电子邮箱" target="_blank">电子邮箱</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">白玉为堂金为马.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.1" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.1"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.1"></script></div></body></html>