<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="周左左个人博客"><meta name="theme-color" content="#795548"><title>Django源码(1) - import apps | 白玉为堂金为马</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.1"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Django源码(1) - import apps</h1><a id="logo" href="/.">白玉为堂金为马</a><p class="description">70%有趣的灵魂</p></div><div id="nav-menu"><a href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a class="current" href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Django源码(1) - import apps</h1><div class="post-content"><p>从runserver开始，终于读到要如何加载project下的所有apps。<br><a id="more"></a></p>
<p>在<code>core/wsgi.py</code>中看见的<code>get_wsgi_application</code> function,虽然只有两行,但都是非常重要的.这篇就来详细谈第一行: <code>django.setup(set_prefix=False)</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_wsgi_application</span><span class="params">()</span>:</span></span><br><span class="line">    django.setup(set_prefix=<span class="keyword">False</span>)</span><br><span class="line">    <span class="keyword">return</span> WSGIHandler()</span><br></pre></td></tr></table></figure>
<p>首先是django.setup函数的全貌:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup</span><span class="params">(set_prefix=True)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> django.apps <span class="keyword">import</span> apps</span><br><span class="line">    <span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line">    <span class="keyword">from</span> django.urls <span class="keyword">import</span> set_script_prefix</span><br><span class="line">    <span class="keyword">from</span> django.utils.log <span class="keyword">import</span> configure_logging</span><br><span class="line"></span><br><span class="line">    configure_logging(settings.LOGGING_CONFIG, settings.LOGGING)</span><br><span class="line">    <span class="keyword">if</span> set_prefix:</span><br><span class="line">        set_script_prefix(</span><br><span class="line">            <span class="string">'/'</span> <span class="keyword">if</span> settings.FORCE_SCRIPT_NAME <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">else</span> settings.FORCE_SCRIPT_NAME</span><br><span class="line">        )</span><br><span class="line">    apps.populate(settings.INSTALLED_APPS)</span><br></pre></td></tr></table></figure>
<p>通过lazyload module的方式导入4个方法: apps, settings, set_script_prefix and configure_logging.</p>
<p>进入django.apps看这个apps,其实是一个<code>apps = Apps(installed_apps=None)</code> Apps class. 可以看出当前installed_apps是None的,猜测之后肯定要从settings的installed_apps里动态加载. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self, installed_apps=()):</span><br><span class="line">    if installed_apps is None and hasattr(sys.modules[__name__], &apos;apps&apos;):</span><br><span class="line">        raise RuntimeError(&quot;You must supply an installed_apps argument.&quot;)</span><br><span class="line">    self.all_models = defaultdict(dict)</span><br><span class="line">    self.app_configs = &#123;&#125;</span><br><span class="line">    self.stored_app_configs = []</span><br><span class="line">    self.apps_ready = self.models_ready = self.ready = False</span><br><span class="line">    self.ready_event = threading.Event()</span><br><span class="line">    self._lock = threading.RLock()</span><br><span class="line">    self.loading = False</span><br><span class="line">    self._pending_operations = defaultdict(list)</span><br><span class="line">    if installed_apps is not None:</span><br><span class="line">        self.populate(installed_apps)</span><br></pre></td></tr></table></figure>
<p>这里名为all_modules的instance variable比较重要,它映射了从app label, model name 到 model class的关系. 每次model被引入, <code>ModelBase.__new__</code>都会调用apps的register_model方法, 它会创建一个<code>entry</code>在all_modules中. 这个是跟model部分有关的事情,之后再说.</p>
<h2 id="apps-populate"><a href="#apps-populate" class="headerlink" title="apps.populate"></a>apps.populate</h2><p>所以Apps class的<strong>init</strong>就先这样了,之后就是重头戏: <code>populate</code>. 它会加载application的configurations和models. 它主要分为3步进行:</p>
<ol>
<li>初始化app config以及import app modules</li>
<li>import models modules</li>
<li>调用每个app config的ready()方法</li>
</ol>
<h3 id="初始化app-config以及import-app"><a href="#初始化app-config以及import-app" class="headerlink" title="初始化app config以及import app"></a>初始化app config以及import app</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Phase 1: initialize app configs and import app modules.</span></span><br><span class="line"><span class="keyword">for</span> entry <span class="keyword">in</span> installed_apps:</span><br><span class="line">    <span class="keyword">if</span> isinstance(entry, AppConfig):</span><br><span class="line">        app_config = entry</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        app_config = AppConfig.create(entry)</span><br><span class="line">    <span class="keyword">if</span> app_config.label <span class="keyword">in</span> self.app_configs:</span><br><span class="line">        <span class="keyword">raise</span> ImproperlyConfigured(</span><br><span class="line">            <span class="string">"Application labels aren't unique, "</span></span><br><span class="line">            <span class="string">"duplicates: %s"</span> % app_config.label)</span><br><span class="line"></span><br><span class="line">    self.app_configs[app_config.label] = app_config</span><br><span class="line">    app_config.apps = self</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check for duplicate app names.</span></span><br><span class="line">counts = Counter(</span><br><span class="line">    app_config.name <span class="keyword">for</span> app_config <span class="keyword">in</span> self.app_configs.values())</span><br><span class="line">duplicates = [</span><br><span class="line">    name <span class="keyword">for</span> name, count <span class="keyword">in</span> counts.most_common() <span class="keyword">if</span> count &gt; <span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> duplicates:</span><br><span class="line">    <span class="keyword">raise</span> ImproperlyConfigured(</span><br><span class="line">        <span class="string">"Application names aren't unique, "</span></span><br><span class="line">        <span class="string">"duplicates: %s"</span> % <span class="string">", "</span>.join(duplicates))</span><br><span class="line"></span><br><span class="line">self.apps_ready = <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>因为我们在调用populate的时候传入了从settings中获取的installed_apps(如何知道的之后说), 所以这里将每个app作为一个entry iterate了一次. 注意,这里的entry其实是string类型, 因为我们在settings里定义的INSTALLED_APPS确实是List<string>的:</string></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = (</span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,</span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,</span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>所以entry肯定不是AppConfig类型的了, 随之会调用AppConfig工厂类的create为我们创建一个app_config. 那这个create方式有什么玄机呢, 能通过短短的string就创建出一个app_config.</p>
<p>首先<code>module = import_module(entry)</code>, 会将entry(string类型哦)作为一个module path进行加载. 因为<code>django.contrib.*</code>这些modules里肯定都配备了<strong>init</strong>.py文件, 所以一般来说是可以加载成功的, 除非你确确实实写了一个错误的路径(比如拼写错误). </p>
<p>一个App的<strong>init</strong>.py文件, 里面应该export一个名为<code>default_app_config</code>的变量, 记录着你的AppConfig class的位置. 比如django.contrib.admin中的<code>__init__.py</code>, 最后一行: <code>default_app_config = &#39;django.contrib.admin.apps.AdminConfig&#39;</code>.</p>
<p>所以, 在获取到module成功后, populate会将entry重新赋值: <code>entry = module.default_app_config</code>. 当然, 懒惰如我, 我一般不改动自动生成的<code>__init__.py</code>文件, 那么就会触发<code>AttributeError</code>, 这时就会直接return一个简单的AppConfig: <code>return cls(entry, module)</code>.</p>
<p>如果确确实实定义了module.default_app_config, 那么create方法就会去找到这个自定义的AppConfig, 然后获取它的一些properties, 从而创建并返回<code>return cls(app_name, app_module)</code>.</p>
<p>回到populate方法, 创建好app_config(是AppConfig的instance)以后, 会将它放入self.app_configs, 并将该app_config的apps引用指向自身: <code>app_config.apps = self</code></p>
<p>之后就是简单地找同名app了, 一旦发现就会报错. 如果没问题, 将self.apps_ready=True, 表示app config已经ready了.</p>
<h2 id="import-models-modules"><a href="#import-models-modules" class="headerlink" title="import models modules"></a>import models modules</h2><p>用过django的我们都知道, 每个app都有<code>models.py</code>文件, 里面放着各种各样的model, 代表了数据库中的Schema. 所以第二步就来加载这些app中的models.</p>
<p>其实挺简单的, 就是iterate刚刚存起来的每个app_config, 然后调用它们的<code>import_models</code>方法: <code>for app_config in self.app_configs.values(): app_config.import_models()</code></p>
<p>进入import_models方法: 首先访问了self.apps的all_models属性, 这个我们之前提到过, 但是却没有提到它是如何添加model的, 这里还是不提, 我们默认self.models就是从apps的all_models中根据label中获取的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def import_models(self):</span><br><span class="line">    # Dictionary of models for this app, primarily maintained in the</span><br><span class="line">    # &apos;all_models&apos; attribute of the Apps this AppConfig is attached to.</span><br><span class="line">    self.models = self.apps.all_models[self.label]</span><br><span class="line"></span><br><span class="line">    if module_has_submodule(self.module, MODELS_MODULE_NAME):</span><br><span class="line">        models_module_name = &apos;%s.%s&apos; % (self.name, MODELS_MODULE_NAME)</span><br><span class="line">        self.models_module = import_module(models_module_name)</span><br></pre></td></tr></table></figure>
<p>之后就是调用了关键的<code>module_has_submodule</code>函数, 用于判断self.module是不是真的有models. 再来回顾一下self.module是什么: 就是我们刚刚传入的app_module(从app_config的name中获取), 例如admin的app_module就是<code>django.contrib.admin</code> 这一整个module.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class AppConfig:</span><br><span class="line">    def __init__(self, app_name, app_module):</span><br><span class="line">        self.name = app_name</span><br><span class="line">        self.module = app_module</span><br><span class="line">        #...</span><br></pre></td></tr></table></figure>
<p>所以<code>module_has_submodule</code>是原理是什么呢?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def module_has_submodule(package, module_name):</span><br><span class="line">    &quot;&quot;&quot;See if &apos;module&apos; is in &apos;package&apos;.&quot;&quot;&quot;</span><br><span class="line">    try:</span><br><span class="line">        package_name = package.__name__</span><br><span class="line">        package_path = package.__path__</span><br><span class="line">    except AttributeError:</span><br><span class="line">        # package isn&apos;t a package.</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">    full_module_name = package_name + &apos;.&apos; + module_name</span><br><span class="line">    try:</span><br><span class="line">        return importlib_find(full_module_name, package_path) is not None</span><br><span class="line">    except (ModuleNotFoundError, AttributeError):</span><br><span class="line">        # When module_name is an invalid dotted path, Python raises</span><br><span class="line">        # ModuleNotFoundError. AttributeError is raised on PY36 (fixed in PY37)</span><br><span class="line">        # if the penultimate part of the path is not a package.</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>
<p>首先获取module(在python概念里是package)的name和path. 然后调用<code>importlib_find</code>去搜索由package name和module name拼接成的full module name与package path. <code>importlib_find</code>其实是<code>find_spec</code>的alias(<code>from importlib.util import find_spec as importlib_find</code>). 用于确定该package下存在models.</p>
<p>回到<code>import_models</code>, 在确定了以后, 就可以将model module导入进来了. 存在self.models_module中. 搞定了以后, 在apps里设置<code>self.models_ready=True.</code></p>
<h2 id="调用每个app-config的ready-方法"><a href="#调用每个app-config的ready-方法" class="headerlink" title="调用每个app config的ready()方法"></a>调用每个app config的ready()方法</h2><p>第三步看起来了非常简单, 调用一下刚刚获取到的所有app_config中的ready方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Phase 3: run ready() methods of app configs.</span></span><br><span class="line"><span class="keyword">for</span> app_config <span class="keyword">in</span> self.get_app_configs():</span><br><span class="line">    app_config.ready()</span><br><span class="line"></span><br><span class="line">self.ready = <span class="keyword">True</span></span><br><span class="line">self.ready_event.set()</span><br></pre></td></tr></table></figure>
<p>我们进入AppConfig却发现, ready方法其实是个虚函数, 是需要override的. 那么我们拿<code>django.contrib.admin</code>中的AppConfig作例子好了, 看看可以通过这个ready干些什么事情.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class SimpleAdminConfig(AppConfig):</span><br><span class="line">    &quot;&quot;&quot;Simple AppConfig which does not do automatic discovery.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    default_site = &apos;django.contrib.admin.sites.AdminSite&apos;</span><br><span class="line">    name = &apos;django.contrib.admin&apos;</span><br><span class="line">    verbose_name = _(&quot;Administration&quot;)</span><br><span class="line"></span><br><span class="line">    def ready(self):</span><br><span class="line">        checks.register(check_dependencies, checks.Tags.admin)</span><br><span class="line">        checks.register(check_admin_app, checks.Tags.admin)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AdminConfig(SimpleAdminConfig):</span><br><span class="line">    &quot;&quot;&quot;The default AppConfig for admin which does autodiscovery.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def ready(self):</span><br><span class="line">        super().ready()</span><br><span class="line">        self.module.autodiscover()</span><br></pre></td></tr></table></figure>
<p>可以看到继承了<code>SimpleAdminConfig</code>类的AdminConfig, 首先调用父类的ready, 调用两个<code>checks.register</code>, 分别检查了admin所需要的dependent apps以及sites. 之后就是之类的<code>autodiscover</code>. 一路寻找, 找到<code>autodiscover_modules</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def autodiscover_modules(*args, **kwargs):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Auto-discover INSTALLED_APPS modules and fail silently when</span><br><span class="line">    not present. This forces an import on them to register any admin bits they</span><br><span class="line">    may want.</span><br><span class="line"></span><br><span class="line">    You may provide a register_to keyword parameter as a way to access a</span><br><span class="line">    registry. This register_to object must have a _registry instance variable</span><br><span class="line">    to access it.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    from django.apps import apps</span><br><span class="line"></span><br><span class="line">    register_to = kwargs.get(&apos;register_to&apos;)</span><br><span class="line">    for app_config in apps.get_app_configs():</span><br><span class="line">        for module_to_search in args:</span><br><span class="line">            try:</span><br><span class="line">                if register_to:</span><br><span class="line">                    before_import_registry = copy.copy(register_to._registry)</span><br><span class="line"></span><br><span class="line">                import_module(&apos;%s.%s&apos; % (app_config.name, module_to_search))</span><br><span class="line">            except Exception:</span><br><span class="line">                if register_to:</span><br><span class="line">                    register_to._registry = before_import_registry</span><br><span class="line">                if module_has_submodule(app_config.module, module_to_search):</span><br><span class="line">                    raise</span><br></pre></td></tr></table></figure>
<p>为了将每个app中admin都绑定为default site admin而做的工作. 首先搜索了所有的app_config, 之后寻找admin module, 然后直接调用import_module导入其中的admin, 放到内存里.</p>
<p>所以总结一下, ready差不多就是等到apps都已经注册好了, 之后再执行一些自己需要的操作, 比如<code>检查</code>和<code>导入</code>等等…</p>
<p>在第三步完成以后, 就会触发一个<code>ready_event</code>事件, 用于通知<code>autoreload</code>可以开始启动了, 至于autoreload怎么工作的, 之后肯定会提到的.</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>django.setup讲解完毕, 下一次开启<code>WSGIHandler</code>!</p>
</div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/摄影/">摄影</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂谈/">杂谈</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/诗/">诗</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.zhihu.com/people/dcalsky" title="知乎" target="_blank">知乎</a><ul></ul><a href="https://github.com/dcalsky" title="Github" target="_blank">Github</a><ul></ul><a href="mailto:dcalsky@gmail.com" title="电子邮箱" target="_blank">电子邮箱</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">白玉为堂金为马.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.1" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.1"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.1"></script></div></body></html>